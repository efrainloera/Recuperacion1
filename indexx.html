<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<script>

// Este metodo FILTER crea una nueva matriz llena de elementos que pasan una prueba proporcionada por una función.
// No ejecuta la función para elementos vacíos.
// No cambia la matriz original.

//CASO DE USO:  Lo primero que estoy haciendo es declarar variables de tipo bebidas para poder trabajar con varios metodos
//despues le estoy diciendo a la consola que busque los productos con cantidad igual o menor a 400

let LasBebidas =[{"nombre":"Cocacola", capacidad: 310 },
{nombre:"Pepsi", capacidad: 400},
{nombre:"Caballitos", capacidad: 350},
{nombre:"Manzanita", capacidad: 310},
{nombre:"Aguamineral", capacidad: 410},
{nombre:"Jugo", capacidad: 500}
];

let LasBebidasChicas = LasBebidas.filter( e => e.capacidad <400);
console.log(LasBebidasChicas); 

//Metodo MAP crea una nueva matriz llamando a una función para cada elemento de la matriz.
//llama a una función una vez para cada elemento en una matriz.
//no ejecuta la función para elementos vacíos.
//no cambia la matriz original

//CASO DE USO: Lo use para que muestre los valores menos la capacidad asignada,
//osea que a todas las bebidas se les restara en este caso -110


let LasBebidasUsadas = LasBebidas.map( e => {
    e.capacidad -= 110;
    return e;
});
console.log(LasBebidasUsadas);

//Metodo REDUCE ejecuta una función reductora para el elemento de matriz.
//método devuelve un único valor: el resultado acumulado de la función.
// no ejecuta la función para elementos de matriz vacíos.
// no cambia la matriz original.

//CASO DE USO: En este ewjemplo ocupe reduce para que haga acumulaciones de la capacidad de las bebidas

let ProductoQueQueda = LasBebidas.reduce( (acumulado, sig) => acumulado + sig.capacidad, 0)
console.log(ProductoQueQueda);

//El metodo FIND devuelve el valor del primer elemento que pasa una prueba.
//método ejecuta una función para cada elemento de la matriz.
// regresa undefinedsi no se encuentran elementos.
// no ejecuta la función para elementos vacíos.
// no cambia la matriz original.

//CASO DE USO: Aqui la funcion find iterara con cada uno de los elementos hasta que llegue con el elemento que busca 
//por asi decirlo

let x = LasBebidas.find(function(bebida){
    return bebida.nombre == 'Manzanita';
});

console.log(x);

//Las PROMESAS son un objeto devuelto al cuál se adjuntan funciones callback ,
// en lugar de pasar callbacks a una función. Llamamos a esto una llamada a función asíncrona

//CASO DE USO: En este caso de las promesa lo unico que mostrar seran mensajes despues de lo segundo asignado 
//mostrara la promesa 2 y igual que la primera solo mostrara el mensaje

const MiPromesa = new Promise((resolve, reject) => {
    console.log("Trabajando");
    setTimeout(function(){
     resolver("Finalizado");
    },3000);

});

const MiPromesa2 = () =>{
    return new Promise((resolve, reject)=>{
        console.log("Trabajando en algo mas")
        setTimeout(function(){
            resolve("Terminado");
        },2000);
    })
}

MiPromesa.then(resultado=>{
    return resultado;
}).then(mensaje => {
     console.log(mensaje);
}).catch(message=>{
    console.error(message);
})

// Hoisting,fue pensado como una manera general de referirse a cómo funcionan los contextos de ejecución en JavaScript 

//CASO DE USO:  se llama a una funcion antes de que esta este definida

let nombre = 'Efrain'

Saludar(nombre)
function Saludar(nombre) {
    console.log(nombre)
}


//El metodo REPLACE devuelve una nueva cadena con algunas o todas las coincidencias de un patrón 

//CASO DE USO: Este es un ejemplo muy sencillo lo unico que estamos haciendo es remplazar el saludo y la despedida

var cadena = "Hola efrain. Nos vemos";
cadena = cadena.replace("Bienvenido", "Chao");
document.write( cadena );


//El metodo findIndex ejecuta una función para cada elemento de la matriz.
//devuelve el índice (posición) del primer elemento que pasa una prueba.
//devuelve -1 si no se encuentra ninguna coincidencia.
//no ejecuta la función para elementos de matriz vacíos.
//no cambia la matriz original.

//CASO DE USO: En este ejemplo lo que estoy haciendo es que con la funcion findIndex le estoy diciendo que busque 
// una de las bebidas que cuente con la capacidad exacta y que elimine ese producto


let bebidas = LasBebidas.findIndex(em => em.capacidad === 400)
LasBebidas.splice(LasBebidas.findIndex(em => em.capacidad === 400), 1)

console.log(LasBebidas)




</script>




</body>
</html>

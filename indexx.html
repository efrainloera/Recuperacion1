<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<script>

// Este metodo FILTER crea una nueva matriz llena de elementos que pasan una prueba proporcionada por una función.
// No ejecuta la función para elementos vacíos.
// No cambia la matriz original.

//CASO DE USO:  Lo primero que estoy haciendo es declarar variables de tipo bebidas para poder trabajar con varios metodos
//despues le estoy diciendo a la consola que busque los productos con cantidad igual o menor a 400

let LasBebidas =[{"nombre":"Cocacola", capacidad: 310 },
{"nombre":"Pepsi", capacidad: 400},
{"nombre":"Caballitos", capacidad: 350},
{"nombre":"Manzanita", capacidad: 310},
{"nombre":"Aguamineral", capacidad: 410},
{"nombre":"Jugo", capacidad: 500}
];

let LasBebidasChicas = LasBebidas.filter( e => e.capacidad <400);
console.log(LasBebidasChicas); 

// Hoisting,fue pensado como una manera general de referirse a cómo funcionan los contextos de ejecución en JavaScript 

//CASO DE USO:  se llama a una funcion antes de que esta este definida

let nombre = 'Efrain'

Saludar(nombre)
function Saludar(nombre) {
    console.log(nombre)
}



//Las PROMESAS son un objeto devuelto al cuál se adjuntan funciones callback ,
// en lugar de pasar callbacks a una función. Llamamos a esto una llamada a función asíncrona

//CASO DE USO: En este caso de las promesa lo unico que mostrar seran mensajes despues de lo segundo asignado 
//mostrara la promesa 2 y igual que la primera solo mostrara el mensaje

const MiPromesa = new Promise((resolve, reject) => {
    console.log("Trabajando");
    setTimeout(function(){
     resolver("Finalizado");
    },3000);

});

const MiPromesa2 = () =>{
    return new Promise((resolve, reject)=>{
        console.log("Trabajando en algo mas")
        setTimeout(function(){
            resolve("Terminado");
        },2000);
    })
}

MiPromesa.then(resultado=>{
    return resultado;
}).then(mensaje => {
     console.log(mensaje);
}).catch(message=>{
    console.error(message);
})


</script>




</body>
</html>